/*
    Compare the pairs that generated by LSH and SetJoin
    Output performance metrics of LSH such as FP FN
*/
#include <iostream>
#include <fstream>
#include <set>
#include "util/io.h"

using namespace std;

// Parameters that indicates the Experiment Object
string dataset_name;
double thres;
double shrink_ratio;

// Assume the size of buffer
const int bufferSize = 10000;
vector<pair<unsigned int, unsigned int>> buffer;
int buffer_id = 100000;
unsigned long long total_left;
bool getBuffer(ifstream &ifs, pair<unsigned int, unsigned int> &res) {
    if (buffer_id >= buffer.size()) {
        // start load the left data into the buffer
        if (total_left <= 0) {
            return false;
        }

        auto readSize = min(total_left, (unsigned long long)bufferSize);
        buffer.resize(readSize);
        ifs.read((char *)&buffer[0], readSize * sizeof(pair<unsigned int, unsigned int>));
        total_left -= readSize;
        buffer_id = 0;
    }

    res = buffer[buffer_id++];
    return true;
}

bool ifnextBuffer() {
    if (buffer_id >= buffer.size() && total_left == 0)
        return false;
    return true;
}

void idmapTwice( vector<pair<unsigned int, unsigned int>> &pairsB, const string &idmap_A_path, const string &idmap_B_path) {
    // Load
    vector<int> idmap_A;
    vector<int> idmap_B;
    loadBin2vec(idmap_A_path, idmap_A);
    loadBin2vec(idmap_B_path, idmap_B);

    // Convert the pairs B from idmapB into original id then using reversed idmap_A to convert it into A's id

    // reverse idmap_A (original id to A's id)
    vector<int> rev_idmap_A(idmap_A.size());
    for (int i = 0; i < idmap_A.size(); i++) {
        rev_idmap_A[idmap_A[i]] = i;
    }

    // mix idmap (B's id to orignal id + original id to A's id)
    for (int i = 0; i < idmap_B.size(); i++) {
        idmap_B[i] = rev_idmap_A[idmap_B[i]];
    }

    // Map id in pairsB
    for (auto &pair : pairsB) {
        pair.first = idmap_B[pair.first];
        pair.second = idmap_B[pair.second];

        if (pair.second < pair.first) {  
            auto tmp =pair.first;
            pair.first = pair.second;
            pair.second = tmp;
        }
    }
    // sort it
    sort(pairsB.begin(),pairsB.end());
}

void rev_idmap( vector<pair<unsigned int, unsigned int>> &pairsB, const string &idmap_A_path) {
    // Load
    vector<int> idmap_A;
    loadBin2vec(idmap_A_path, idmap_A);
    vector<int> rev_idmap_A(idmap_A.size());
    for (int i = 0; i < idmap_A.size(); i++) {
        rev_idmap_A[idmap_A[i]] = i;
    }
    // Convert the pairs B from idmapB into original id then using reversed idmap_A to convert it into A's id

    // Map id in pairsB
    for (auto &pair : pairsB) {
        pair.first = rev_idmap_A[pair.first];
        pair.second = rev_idmap_A[pair.second];

        if (pair.second < pair.first) {  
            auto tmp =pair.first;
            pair.first = pair.second;
            pair.second = tmp;
        }
    }
    // sort it
    sort(pairsB.begin(),pairsB.end());
}


// fileA -> Lskech
// fileB -> Setjoin
void compareFiles(const string &fileA, const string &fileB, const string &idmap_A_path ) {
    // Read the pairs from the binary files
    vector<pair<unsigned int, unsigned int>> pairsA;
    ifstream ifsA(fileA, ios::binary | std::ios::ate);
    cout << fileA << endl;
    std::streamsize total_bytes = ifsA.tellg();
    cout << total_bytes << endl;
    // for those file have amount first
    ifsA.seekg(sizeof(unsigned long long), std::ios::beg);
    // ifsA.seekg(0, std::ios::beg);
    total_bytes -= sizeof(std::pair<unsigned int, unsigned int>);

    total_left = total_bytes / sizeof(std::pair<unsigned int, unsigned int>);

    cout << total_left << endl;

    unsigned long long pairsA_size = total_left;
    if (!ifsA.is_open()) {
        cerr << "Failed to open the files." << endl;
        return;
    }

    // readSimilarPair(fileA, pairsA);
    vector<pair<unsigned int, unsigned int>> pairsB;
    readSimilarPair(fileB, pairsB);
    rev_idmap(pairsB, idmap_A_path);
    // idmapTwice(pairsB, idmap_A_path, idmap_B_path);
    
    set<unsigned int> uniqueValuesA;
    set<unsigned int> uniqueValuesB;

    unsigned long long pairsInAnotInB = 0;
    unsigned long long pairsInBnotInA = 0;
    int valuesInAnotInB = 0;
    int valuesInBnotInA = 0;
    unsigned long long intersectionSize = 0;
    size_t i = 0, j = 0;

    pair<unsigned int, unsigned int> pairA;
    getBuffer(ifsA, pairA);

    while (j < pairsB.size()) {
        pair<unsigned int, unsigned int> pairB = pairsB[j];

        uniqueValuesA.insert(pairA.first);
        uniqueValuesA.insert(pairA.second);
        uniqueValuesB.insert(pairB.first);
        uniqueValuesB.insert(pairB.second);

        if (pairA < pairB) {
            pairsInAnotInB++;
            if (getBuffer(ifsA, pairA) == false) break;
        } else if (pairB < pairA) {
            pairsInBnotInA++;
            j++;
        } else {
            intersectionSize++;
            j++;
            if (getBuffer(ifsA, pairA) == false) break;
        }
    }

    cout << "There out";
    while (ifnextBuffer()) {
        getBuffer(ifsA, pairA);
        uniqueValuesA.insert(pairA.first);
        uniqueValuesA.insert(pairA.second);
        pairsInAnotInB++;
    }

    while (j < pairsB.size()) {
        pair<unsigned int, unsigned int> pairB = pairsB[j];
        uniqueValuesB.insert(pairB.first);
        uniqueValuesB.insert(pairB.second);
        pairsInBnotInA++;
        j++;
    }

    // Calculate values
    for (const auto &value : uniqueValuesA)
        if (uniqueValuesB.count(value) == 0)
            valuesInAnotInB++;

    for (const auto &value : uniqueValuesB)
        if (uniqueValuesA.count(value) == 0)
            valuesInBnotInA++;

    cout << "Pairs in file A: " << pairsA_size << endl;
    cout << "Pairs in file B: " << pairsB.size() << endl;
    cout << "Unique values in file A: " << uniqueValuesA.size() << endl;
    cout << "Unique values in file B: " << uniqueValuesB.size() << endl;
    cout << "FP_pairs:  " << pairsInAnotInB << endl;
    cout << "FN_pairs: " << pairsInBnotInA << endl;
    cout << "FP_ids: " << valuesInAnotInB << endl;
    cout << "FN_ids: " << valuesInBnotInA << endl;
    double pairs_fp_rate = 1.0 * pairsInAnotInB / pairsA_size;
    double pairs_fn_rate = 1.0 * pairsInBnotInA / pairsB.size();
    double precision = 1.0 * intersectionSize / (intersectionSize + pairsInAnotInB);
    double recall = 1.0 * intersectionSize / (intersectionSize + pairsInBnotInA);
    double f1 = 2.0 * (precision * recall) / (precision + recall);
    double ids_fp_rate = 1.0 * valuesInAnotInB / uniqueValuesA.size(); 
    double ids_fn_rate = 1.0 * valuesInBnotInA / uniqueValuesB.size();

    printf(" %s thres %.2f shrink_ratio %.2f \n ", dataset_name.c_str(), thres, shrink_ratio);
    printf("| %llu | %.5f | %.5f|%.5f|%lu|%.5f|%.5f|\n", pairsA_size, pairs_fp_rate, pairs_fn_rate, f1, uniqueValuesA.size(), ids_fp_rate, ids_fn_rate);
}

int main(int argc, char *argv[]) {
    dataset_name = string(argv[1]);
    int M;
    for (int i = 1; i < argc; i++) {
        const string arg = argv[i];
        if (arg == "-t") {
            char* end;
            thres = strtod(argv[i + 1], &end);
        }

        if (arg == "-r") {
            char* end;
            shrink_ratio = strtod(argv[i + 1], &end);
        }

        if (arg == "-m") {
            M = stoi(argv[i + 1]);
        }
    }

    const string fileA_simp_path = "/research/projects/zp128/RedPajama_Analysis/SetJoin/data/ngram/sorted_lsketchsimp/" + dataset_name + "_sim_pairs_" + to_string(thres) + "_M" + to_string(M) + ".bin";
    const string fileB_simp_path = "/research/projects/zp128/RedPajama_Analysis/SetJoin/data/ngram/sorted_simp/" + dataset_name + "_sim_pairs_" + to_string(thres) + ".bin";
    const string fileA_idmap_path = "/research/projects/zp128/RedPajama_Analysis/SetJoin/data/ngram/sorted_lsketch/" + dataset_name + "_M" + to_string(M) + "_idmap" + ".bin";
    // const string fileB_idmap_path = "/research/projects/zp128/RedPajama_Analysis/SetJoin/data/ngram/sorted_ngrams/" + dataset_name + "_idmap" + ".bin";

    // Due to the two sorted similar pairs have different idmap, we cannot directly compare them linearly
    // Therefore, we need to convert the sim_pairs from fileB by the idmap from both
    compareFiles(fileA_simp_path, fileB_simp_path, fileA_idmap_path);
}
